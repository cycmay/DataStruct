# DataStruct-Notes

## 引论

### 数学知识

列出一些需要记住或是能够推导出的基本公式，并且附上基本的证明方法。

#### 指数

![image-20200324141124414](imgs/DS-fig1.png)

#### 对数

在计算机科学中，所有的对数都是以2为底的，除非另有声明。

$X^A=B$ 等价于 $logX_B=A$ .

$log_AB=\frac{log_CB}{log_CA}$, A,B,C>0, A!=1

![image-20200324141943710](imgs/DS-fig2.png)

$log_AB=logA+logB$ 

其他一些有用的公式：

$logA/B=logA-logB$

$log(A^B)=BlogA$

$logX<X$对所有的X>0成立

$log1=0, log2=1, log1024=10, log1048576=20$

#### 级数

最容易记住的公式：

$\sum_{i=0}^N2^i = 2^{N+1}-1$

和

$\sum_{i=0}^NA^i=\frac{A^{N+1}-1}{A-1}$

如果0<A<1, 则有 $\sum_{i=0}^NA^i<=\frac{1}{1-A}$ , 当N趋近于无穷时，该和趋向于$1/(1-A)$

#### 模运算

#### 证明方法

**归纳法证明**

归纳法证明有两个标准的部分，第一步是证明基准情形(base case)，就是确定定理对某个(某些)小的值得正确性；接着，进行归纳假设(inductive hypothesis)，一般来说，这意味着假设定理对直到某个有限数k的所有情况都是成立的；然后使用这个假设来证明定理对下一个值(通常是k+1)也是成立的。至此定理得证(通常k是有限的)。

栗子，证明斐波那契数列，即$F_0=1, F_1=1, F_2=2, F_3=3, F_4=5, … , F_i = F_{i-1} + F_{i-2}$, 满足对i>=1, 有$F_i<(5/3)^i$.

1.  为了证明这个不等式，首先验证定理对平凡情形成立。容易验证$F_1=1<5/3$及$F_2=2<25/9$;这就证明了基准情形。
2.  假设定理对于$i = 1,2,3, … , k$ 成立；这就是归纳假设。
3.  为了证明定理，需要证明$F_{k+1}<(5/3)^{k+1}$。

根据定义有

$F_{k+1}=F_k+F_{k-1}$

将归纳假设用于等号右边，得到

$F_{k+1}<(5/3)^k+(5/3)^{k-1}$

$<(3/5)(5/3)^{k+1}+(3/5)^2(5/3)^{k+1}$

$<(3/5)(5/3)^{k+1}+(9/25)(5/3)^{k+1}$

化简：

$F_{k+1}<(3/5+9/25)(5/3)^{k+1}$

$<(24/25)(5/3)^{k+1}$

$<(5/3)^{k+1}$

定理得证。

**反证法证明**

反证法证明是通过假设定理不成立，然后证明该假设导致某个已知的性质不成立，从而证明原假设是错误的。

### 递归

递归的两个基本法则

1.  基准情形(base cases)。必须总有某些基准的而情形，他们不用递归就能求解。
2.  不断推进(making progress)。对于那些要被递归求解的情形，递归调用必须总能够朝着一个基准情形推进。

## 算法分析

### 数学基础

估计算法资源消耗是一个理论问题，因此需要一套正式的系统架构。先从数学定义开始。

1.  如果存在正整数$c$和$n_0$使得当$N>=n_0$时$T(N)<=cf(N)$, 则记为$T(N)=O(f(N))$
2.  如果存在正整数$c$和$n_0$使得当$N>=n_0$时$T(N)>=cg(N)$, 则记为$T(N) = \Omega(g(N))$
3.  当且仅当$T(N)=O(h(N))$同时$T(N) = \Omega(h(N))$，存在$T(N)=\Theta(h(N))$

例如，当N较小时，1000N要比$N^2$大；但是N=1000是转折点。令$T(N)=1000N$, $f(N)=N^2$, $n_0=1000$, $c=1$，因此我们可以说$1000N=O(N^2)$。

当我们说$T(N)=O(f(N))$时，我们是在保证函数$T(N)$是在以不快于$f(N)$的速度增长，因此$f(N)$是$T(N)$的一个**上界（upper bound）**；令一方面$f(N)=\Omega(T(N))$, 表示$T(N)$是$f(N)$的一个**下界(lower bound)**.

例如，$N^3$增长比$N^2$快，因此$N^2=O(N^3)$或者$N^3=\Omega(N^2)$；$f(N)=N^2$和$g(N)=2N^2$以相同的速率增长，从而$f(N)=O(g(N))$和$f(N)=\Omega(g(N))$都是正确的，即可以用$f(N)=\Theta(g(N))$表示。

几个重要的结论：

1.  如果$T_1(N)=O(f(N))$ 且$T_2(N)=O(g(N))$, 那么

    a. $T_1(N)+T_2(N) = O(f(N)+g(N))$, 非正式表达为$max(O(f(N)), O(g(N)))$

    b. $T_1(N)T_2(N) = O(f(N)g(N))$

2.  如果$T(N)$是一个k次多项式，则$T(N)=\Theta(N^k)$

3.  对任意常数k，$log^{k}N=O(N)$. 更直观的表示出对数增长非常缓慢

常见的函数增长率如下：

| 函数     | 名称       |
| -------- | ---------- |
| $c$      | 常量       |
| $logN$   | 对数       |
| $log^2N$ | 对数的平方 |
| $N$      | 线性       |
| $NlogN$  |            |
| $N^2$    | 二次       |
| $N^3$    | 三次       |
| $2^N$    | 指数       |

### 模型

为了在形式的框架中分析算法，我们需要一个计算模型。

我们的模型基本上是一台标准的计算机，在机器中指令被顺序地执行。该模型有一个标准的简单指令系统，如加法、乘法、比较和赋值等。为了简单起见，模型机做任意一件简单的工作都恰好花费一个时间单位。假设模型机有定长(如32位整数)并且不存在矩阵运算。假设模型机有无限内存。

### 运行时间计算

以计算$\sum_{i=1}^{N}i^3$为例的程序段

```c
int sum(int n)
{
	int partialSum;
    
    partialSum = 0;						// 1
    for(int i = 1; i <= n; i++)			// 2
        partialSum += i * i * i;		// 3
    return partialSum;					// 4
}
```

声明不计时间。

第一行和第四行各占1个单位时间。

第三行每执行一次占用4个单位时间(两个乘法、一次加法和一次赋值)，执行N次占用4N个单位时间。

第二行在初始化i，测试i<=N和i的自增运算开销总计为：初始化消耗1个时间单位，测试消耗（1+N）个时间单位，自增运算消耗N个时间单位，共计2N+2。

我们可以忽略调用方法和返回值的开销，计算出消耗总量是6N+4。因此，本程序是$O(N)$.

事实上，我们没有必要必须做上述详细的步骤计算，由于最终只是给出大Od的结果，因此采取捷径并不影响最后的结果。例如，第三行每次执行时显然是$O(1)$的语句，因此无须讨论到底是2、3还是4个单位时间；另外，第一行与for循环相比无关紧要。

#### 一般法则

1.  for循环。一个for循环的运行时间至多是该for循环内语句的运行时间乘以迭代次数。

2.  嵌套循环。从里向外分析这些循环。在一组嵌套循环内部的一条语句总的运行时间为该语句的运行时间乘以该组多有循环的大小的乘积。

    例如：$O(N^2)$的程序片段

    ```
    for(i=0,i<n;i++)
    	for(j=0;j<n;j++)
    		k++
    ```

3.  顺序语句。将各个语句的运行时间求和即可(一般取运行时间的最大值)。

    例如，下面的程序段先是花费$O(N)$, 接着花费$O(N^2)$，因此总量是$O(N^2)$.

    ```
    for(i=0;i<n;i++)
    	a[i]=0;
    for(i=0;i<n;i++)
    	for(j=0;j<n;j++)
    		a[i]+=a[j]+i+j;
    ```

4.  if/else语句。对于程序片段：

    ```
    if(condition)
    	S1
    else
    	S2
    ```

    一个if/else语句的运行时间不超过判断再加上$S_1$和$S_2$中运行时间较长者的总的运行时间。

#### 算法实例

**最大子序列和问题**    

给定整数$A_1, A_2, … ，A_N$ (有可能存在负数)，求$\sum_{k=i}^{j}A_k$的最大值。(为了方便起见，如果所有整数均为负数，则最大子序列和为0.)

例如：对于输入`-2, 11, -4, 13, -5, -2` 答案为20(从$A_2$到$A_4$).

解法1. 暴力搜索

穷举式地尝试所有的可能：

```cpp
int maxSubSum1(const vector<int> &a)
{
	int maxSum = 0;
    for(int i=0; i<a.size(); i++)
    {   for(int j=i; j<a.size(); j++)
        {
            int thisSum = 0;
            // add i to j
            for(int k=i; k<=j; k++)
                thisSum += a[k];
            // jduge if maxSum occur
            if(thisSum > maxSum)
                maxSum = thisSum;
        }
    }
    return maxSum;
}
```

粗略分析运行时间为$O(N^3)$, 这取决于第9行和第10行，第10行是三重嵌套for循环的O(1)语句。第9行表示的第二个循环大小为N-i, 可能很小，但也可能取N，我们必须假设最坏的情况。第三个循环大小为$j-i+1$, 我们也要假设它的大小为N。

解法2.改进的暴力搜索

在解法1中，包含着大量不必要的计算。计算$\sum^j_{k=i}A_k = A_j+\sum^{j-1}_{k=i}A_k$, 因此算法中第9行的计算是重复计算耗费时间的。对此改进，将第三层for循环去掉，更改为记录每次j读取到的数值。

```cpp
int maxSubSum1(const vector<int> &a)
{
	int maxSum = 0;
    for(int i=0; i<a.size(); i++)
    {   
        int thisSum = 0;
        for(int j=i; j<a.size(); j++)
        {
           thisSum += a[j]; 
           if(thisSum > maxSum)
               maxSum = thisSum;
        }
    }
    return maxSum;
}
```

算法2显然是$O(N^2)$的。

解法3.采用递归——分治

该方法采用一种"分治"(divide-and-conquer)策略。就是把问题分成两个大致相等的子问题，然后递归地对它们进行求解；在"治"的阶段，将两个子问题的解合并到一起并尽可能的再做少量的附加工作，最后得到整个问题的解。

在本栗子中，最大子序列和可能出现在三个地方：1.整个出现在输入数据的左半部，2.整个出现在数据的右半部，3.跨越输入数据的中部占据两半部分。前两种情况可以使用递归求解，第三种情况可以通过求出前半部分(包含前半部分的最后一个元素)的最大和以及后半部分(包含后半部分的第一个元素)的最大和，并将二者相加而得到，

```cpp
int m_max3(int a, int b, int c);

int maxSumRec(const vector<int> &a, int left, int right)
{
	// base case
	if(left == right)
    {	// 题目指出子序列若全为负数则返回0
		if(a[left]>0)
            return a[left];
        else
            return 0;
    }
    int center = (left + right)/2;
	int maxLeftSum = maxSumRec(a, left, center);
	int maxRightSum = maxSumRec(a, center+1, right);

	int maxLeftBorderSum = 0, leftBorderSum = 0;
	for(int i=center; i>=left; i--)
	{
		leftBorderSum += a[i];
		if(leftBorderSum>maxLeftBorderSum)
			maxLeftBorderSum = leftBorderSum;
	}	

	int maxRightBorderSum = 0, rightBorderSum = 0;
	for(int i=center+1; i<=right; i++)
	{
		rightBorderSum += a[i];
		if(rightBorderSum>maxRightBorderSum)
			maxRightBorderSum = rightBorderSum;
	}

	return m_max3(maxLeftSum, maxRightSum, maxLeftBorderSum+maxRightBorderSum);

}

int m_max3(int a, int b, int c)
{
	int max = a;

	if(b>max)
		max = b;
	if(c>max)
		max = c;

	return max;
}

```

递归调用的一般形式是传递输入数组以及左右边界，它们界定了数组要被处理的部分。最后，通过单行驱动程序输入原始数组以及0和N-1调用算法。

首先说明基准情况(base-case)，当数组内只有一个元素时(`left==right`)，它就是最大子序列，然而题目指明最大子序列不为全负，所以若为负将其置0；第14行和第15行调用两个递归调用，因为递归总是去解决小于原问题的问题，所以计算center将原始数组分成左右两部分，并重新计算输入参数。两个递归调用可以计算左右两部分最大和；随后计算包含左半部分最后一个元素的最大和以及包含右半部分第一个元素的最大和(即前面叙述的第三种情况)二者相加，这部分就像是动态单向增长；最后通过调用`m_max3`求出上述三种情况最大值，即为本次调用所得最大子序列和。

**运行时间分析**

令$T(N)$是求解大小为N的最大子序列和所花费的时间。如果N=1，则算法执行第8行到第11行花费常数级单位时间，可以计算为O(1)，于是T(1)=1；如果N!=1，程序需执行第18行到第31行的两个for循环，这两个循环需读取N个元素，因此花费时间为O(N)，其余部分执行花费均为常量级，与N相比可以忽略；如果N!=1，程序还需执行两个大小为N/2的子序列问题，即13到15行，因此这三行花费时间为2T(N/2)单位时间。

得到算法总的花费时间为
$$
T(N)=
	\begin{cases}
		1,  & \text{N=1} \\
		2T(N/2)+O(N), & \text{N!=1}
	\end{cases}
$$
这里进行简化求解得到$T(N)=O(NlogN)$.

#### 有关对数时间

可以观察到，分治算法将以O(NlogN)的时间运行，一般的：

如果一个算法用常数时间O(1)将问题的大小削减为其一部分(通常是1/2)，那么该算法就是O(Nlog(N))的。

**二分搜索**

给定一个整数X和整数$A_0, A_1, A_2, …, A_{N-1}$, 后者序列已经预先排序并在内存中，求下标i使得$A_i=X$, 如果X不在数据中，则返回-1.

明显的算法是从左到右顺序扫描数据，花费时间为线性的。然而，这个算法没有用到该表已经排序的事实。另外一个策略是，验证X是否是中间位置元素，若是则找到答案；如果X小于中间元素，那么使用同样的策略用于左半部分已排序的子序列；如果X大于中间元素，那么检查数据的右半部分。当仅剩下一个元素，直接判断即可(base case)。

```cpp
template <typename Comparable>
int binarySearch(const std::vector<Comparable> &a, const Comparable x){
    int low = 0, high = int(a.size()-1);
    while(low <= high){
        int mid = (low+high)/2;
        if(a[mid]<x)
            low = mid + 1;
        else if(a[mid]>x)
            high = mid - 1;
        else
            return mid;
    }
    return NOT_FOUND;
}
```

显然，每次迭代在循环内所有工作花费时间为O(1)，因此分析需要确定的循环次数。循环从high-low=N-1开始，并在high-low>=-1结束。每次循环后high-low的值至少将该次循环前的值减半；因此，循环的次数最多为$[log(N-1)]+2$.所以，运行时间总计为$O(logN)$。

**欧几里得算法**

欧几里得算法用来计算最大公因数。两个整数的最大公因数(gcd)是同时整除二者的最大整数。例如gcd(50,15)=5.

对于算法`gcd(M,N)`，假设M>=N. 如果 M<N ，在循环的第一次迭代后会交换二者的值。

```cpp
long gcd(long m, long n){
	while(n!=0){
        long rem = m%n;
        m = n;
        n = rem;
    }
    
	return m;
}
```

算法通过连续计算余数直到余数是0为止。最后的非零余数就是最大公因数。不难看出，在两次迭代后，余数最多是原始值的一半。所以迭代次数最多是2logN = O(logN)

**幂运算**

计算$X^N$的算法是使用$N-1$次乘法自乘。但是使用递归算法会更好，N<=1是递归的基准情况。如果N是偶数，有$X^N=X^{N/2}·X^{N/2}$；如果N是奇数，有$X^N=X^{(N-1)/2}·X^{(N-1)/2}·X$.

例如，计算$X^{62}$:

$X^{62}=(X^{31})^2$, $X^{31}=(X^{15})^2$, $X^{15}=(X^7)^2$, $X^7=(X^3)^2$, $X^3=(X^2)X$

显然，所需要的乘法次数最多是2logN，因为把问题分半最多需要两次乘法

```cpp
long pow(long x, int n){
	if(n==0)
        return 1;
    if(n==1)
        return x;
    if(isEven(n))
        return pow(x * x, n/2);
    else
        return pow(x * x, (n-1)/2) * x;
}
```

表、栈和队列